sum_delta_1_resid ~ abs_delta_software_1 + factor(year) + factor(Code),
sum_delta_1 ~ abs_delta_it_1 + factor(year) + factor(Code),
sum_delta_1_resid ~ abs_delta_it_1 + factor(year) + factor(Code),
sum_delta_1 ~ abs_delta_compq_1 + factor(year) + factor(Code),
sum_delta_1_resid ~ abs_delta_compq_1 + factor(year) + factor(Code)
)
formula_names <- c(
"sum_1_software_abs",
"sum_resid_1_software_abs",
"sum_1_it_abs",
"sum_resid_1_it_abs",
"sum_1_compq_abs",
"sum_resid_1_compq_abs"
)
results <- lapply(formulas, reg_wrapper, data = regression_data_sum)
names(results) <- formula_names
#######################
# Slides regression
#######################
coef_map <- list(
"abs_delta_software_1" = "Correlation",
"abs_delta_it_1" = "Correlation",
"abs_delta_compq_1" = "Correlation",
"abs_delta_software_5" = "Correlation",
"abs_delta_it_5" = "Correlation",
"abs_delta_compq_5" = "Correlation",
"abs_delta_software_10" = "Correlation",
"abs_delta_it_10" = "Correlation",
"abs_delta_compq_10" = "Correlation")
#######################
# OG regressions comparison
#######################
texreg(list(results[['sum_resid_1_software_abs']][[1]], results[['sum_resid_1_compq_abs']][[1]], results[['sum_resid_1_it_abs']][[1]]), override.se = list(results[['sum_resid_1_software_abs']][[2]], results[['sum_resid_1_compq_abs']][[2]], results[['sum_resid_1_it_abs']][[2]]), override.pvalues = list(results[['sum_resid_1_software_abs']][[3]], results[['sum_resid_1_compq_abs']][[3]], results[['sum_resid_1_it_abs']][[3]]), custom.coef.map = coef_map, custom.model.names = c("Software", "Computer", "IT"), include.rsquared = FALSE, include.adjrs = FALSE, stars = c(.1, .05, .01), table = FALSE, file = "../tables/og_resid_Int_mainresults_1yr.tex")
texreg(list(results[['sum_resid_1_software_abs']][[1]], results[['sum_resid_1_compq_abs']][[1]], results[['sum_resid_1_it_abs']][[1]]), override.se = list(results[['sum_resid_1_software_abs']][[2]], results[['sum_resid_1_compq_abs']][[2]], results[['sum_resid_1_it_abs']][[2]]), override.pvalues = list(results[['sum_resid_1_software_abs']][[3]], results[['sum_resid_1_compq_abs']][[3]], results[['sum_resid_1_it_abs']][[3]]), custom.coef.map = coef_map, custom.model.names = c("Software", "Computer", "IT"), include.rsquared = FALSE, include.adjrs = FALSE, stars = c(.1, .05, .01), table = FALSE)
library(ggplot2)
library(dplyr)
library(fixest)
library(xtable)
# load residuals data
# load("../data/cleaned/resid_results_1997_2022.RData")
# maybe worth thinking about including main effect of prices
# Extract coefficient names
coef_names <- names(coef(model_delta_1))
# Compute confidence intervals for logPratio_1:industry_year terms
intervals <- confint(model_delta_1, parm = grep(":logPratio_1", coef_names, value = TRUE))
# Convert the intervals to a data frame for plotting
intervals_df <- as.data.frame(intervals)
intervals_df$term <- rownames(intervals_df)
colnames(intervals_df) <- c("lower", "upper", "term")
# Check if 0 is within each interval
intervals_df$includes_zero <- intervals_df$lower <= 0 & intervals_df$upper >= 0
# Calculate the percentage of intervals that include 0
percent_include_zero <- mean(intervals_df$includes_zero)
# Plot the confidence intervals with vertical error bars
ggplot(intervals_df, aes(x = term, y = 0)) +
geom_errorbar(aes(ymin = lower, ymax = upper, color = includes_zero), width = 0.2) +
geom_point(aes(y = (lower + upper) / 2, color = includes_zero)) +
labs(x = "Interaction terms",
y = "Confidence Interval",
color = "Includes Zero",
caption = paste("Percent overlapping: ", round(percent_include_zero, 2))) +
theme_minimal() +
theme(axis.text.x = element_blank(), text = element_text(family = "serif", size = 24), legend.position = "bottom")
ggsave("../figures/theory/elasticity_change_Int.pdf", width = 16, height = 9)
# comparing ests on theta vs delta_theta
coef_names <- names(coef(model_delta_1))
delta_theta <- as.data.frame(coef(model_delta_1)[grep(":logPratio_1", coef_names, value = TRUE)])
colnames(delta_theta) <- "delta_theta"
theta <- as.data.frame(coef(model_delta_1)[grep(":delta_logPratio_1", coef_names, value = TRUE)])
colnames(theta) <- "theta"
# make dataframe of first quartile, median, third quartile for delta_theta and theta
quartiles <- c(0.25, 0.5, 0.75)
delta_theta_quartiles <- as.data.frame(apply(delta_theta, 2, quantile, probs = quartiles))
theta_quartiles <- as.data.frame(apply(theta, 2, quantile, probs = quartiles))
merged_quartiles <- rbind(t(delta_theta_quartiles), t(theta_quartiles))
# round values to 2 decimal places
merged_quartiles <- round(merged_quartiles, 2)
rownames(merged_quartiles) <- c("$\\alpha_{it}$", "$\\beta_{it}$")
colnames(merged_quartiles) <- c("1st Quartile", "Median", "3rd Quartile")
# make latex table of merged_quartiles
merged_quartiles_table <- xtable(merged_quartiles, )
print(merged_quartiles_table, floating = FALSE, file = "../tables/elasticity_quartiles_Int.tex", sanitize.text.function=function(x){x})
resid_data_clean$industry <- factor(resid_data_clean$Code)
model_delta_1_alt <- feols(delta_1 ~ industry_year + delta_logPratio_1_II:industry, data = resid_data_clean)
resid_results_alt <- resid_data_clean
resid_results_alt$delta_1_resid <- model_delta_1_alt$residuals
# Extract coefficient names
coef_names <- names(coef(model_delta_1_alt))
# Extract coefficients for delta_logPratio_1_II: terms
estimates <- coef(model_delta_1_alt)[grep("delta_logPratio_1_II", coef_names)]
estimates <- as.data.frame(estimates)
estimates$term <- rownames(estimates)
# separate term in 2 terms by :
estimates$Code <- gsub("delta_logPratio_1_II:industry", "", estimates$term)
estimates$theta <- 1 - estimates$estimate
# merge m:1 with resid_results_alt
resid_results_alt <- merge(resid_results_alt, estimates, by = "Code")
resid_results_alt$delta_1_resid <- resid_results_alt$delta_1_resid/resid_results_alt$theta
# Compute confidence intervals for logPratio_1:industry_year terms
intervals <- confint(model_delta_1_alt, parm = grep("delta_logPratio_1_II", coef_names, value = TRUE))
# Convert the intervals to a data frame for plotting
intervals_df <- as.data.frame(intervals)
intervals_df$term <- rownames(intervals_df)
colnames(intervals_df) <- c("lower", "upper", "term")
intervals_df <- merge(intervals_df, estimates, by = "term")
# change all values in intervals_df to 1-value
intervals_df$upper_theta <- 1 - intervals_df$lower
intervals_df$lower_theta <- 1 - intervals_df$upper
intervals_df$theta <- 1 - intervals_df$estimate
# Check complements or substitutes
intervals_df$complements <- intervals_df$upper_theta < 1
intervals_df$substitutes <- intervals_df$lower_theta > 1
intervals_df$sub_zero <- intervals_df$theta > 0
# Calculate the percentage of intervals that include 0
percent_comp <- mean(intervals_df$complements)
percent_sub <- mean(intervals_df$substitutes)
# Plot the confidence intervals with vertical error bars
ggplot(intervals_df, aes(x = term, y = 0)) +
geom_errorbar(aes(ymin = lower_theta, ymax = upper_theta, color = sub_zero), width = 0.2) +
geom_point(aes(y = theta, color = sub_zero)) +
labs(x = expression(~theta[i]),
y = "Confidence Interval",
color = "Includes Zero") + theme_minimal() +
theme(axis.text.x = element_blank(), text = element_text(family = "serif", size = 24), legend.position = "none")
ggsave("../figures/theory/elasticity_est_Int.pdf", width = 16, height = 9)
library(lpirfs)
library(plm)
library(dplyr)
library(ggplot2)
source("helper_fncts.R")
# load residuals data
load("../data/cleaned/resid_results_1997_2022.RData")
# load BEA + Patents data
load("../data/cleaned/BEA_ILPA_data.RData")
load("../data/cleaned/patent_data_agg.RData")
load("../data/cleaned/summary_naics_crosswalk.RData")
# we have to use Code_patent, to account for multiple Codes mapping to some NAICS 3-digit
temp <- resid_results[, c("Code", "year", "delta_1", "delta_1_resid")]
temp <- merge(temp, summary_naics_crosswalk, by = "Code")
panel_data <- temp %>%
group_by(Code_patent, year) %>%
summarise(
sum_delta_1 = sum(abs(delta_1), na.rm = TRUE),
sum_delta_1_resid = sum(abs(delta_1_resid), na.rm = TRUE)
)
panel_data <- merge(panel_data, patent_data_agg, by = c("Code_patent", "year"), all.x = TRUE, all.y = FALSE)
panel_data <- panel_data[, c("Code_patent", "year", "sum_delta_1", "sum_delta_1_resid", "patents_xi_real", "patents_num", "patents_cites")]
# local projections
patents_lp_og <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1", shock = "patents_xi_real", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_resid <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_xi_real", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_og_alt <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1", shock = "patents_cites", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_resid_alt <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_cites", confint = 1.65, hor = 15, cumul_mult = FALSE)
# plot and save
patents_lp_both <- graph_lp_both(patents_lp_og, patents_lp_resid)
patents_lp_both_alt <- graph_lp_both(patents_lp_og_alt, patents_lp_resid_alt)
patents_lp <- graph_lp_one(patents_lp_resid, "resid")
patents_lp_alt <- graph_lp_one(patents_lp_resid_alt, "resid")
ggsave("../figures/local_projections/patents_lp_Int_both.pdf", patents_lp_both, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int_both_alt.pdf", patents_lp_both_alt, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int_alt.pdf", patents_lp_alt, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int.pdf", patents_lp, width = 9, height = 9)
patents_lp
patents_lp_alt
patents_lp_both
patents_lp_both_alt
library(lpirfs)
library(plm)
library(dplyr)
library(lmtest)
# load BEA + Patents data
load("../data/cleaned/BEA_ILPA_data.RData")
load("../data/cleaned/patent_data_agg.RData")
load("../data/cleaned/summary_naics_crosswalk.RData")
# we have to use Code_patent, to account for multiple Codes mapping to some NAICS 3-digit
temp <- resid_results_alt[, c("Code", "year", "delta_1", "delta_1_resid")]
temp <- merge(temp, summary_naics_crosswalk, by = "Code")
panel_data_alt <- temp %>%
group_by(Code_patent, year) %>%
summarise(
sum_delta_1 = sum(abs(delta_1), na.rm = TRUE),
sum_delta_1_resid = sum(abs(delta_1_resid), na.rm = TRUE)
)
panel_data_alt <- merge(panel_data_alt, patent_data_agg, by = c("Code_patent", "year"), all.x = TRUE, all.y = FALSE)
panel_data_alt <- panel_data_alt[, c("Code_patent", "year", "sum_delta_1", "sum_delta_1_resid", "patents_xi_real", "patents_num", "patents_cites")]
# local projections
patents_lp_omega <- lp_lin_panel(panel_data_alt, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_xi_real", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_omega_alt <- lp_lin_panel(panel_data_alt, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_cites", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_omega <- graph_lp_one(patents_lp_omega, "resid")
patents_lp_omega_alt <- graph_lp_one(patents_lp_omega_alt, "resid")
ggsave("../figures/local_projections/patents_lp_Int_altResid.pdf", patents_lp_omega, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int_altResid_alt.pdf", patents_lp_omega_alt, width = 16, height = 9)
#######################
# Regression
#######################
load("../data/cleaned/BEA_ILPA_data.RData") # pre-cleaned in cleaning code
columns_to_abs <- c(
"delta_software_1", "delta_software_5", "delta_software_10",
"delta_it_1", "delta_it_5", "delta_it_10",
"delta_compq_1", "delta_compq_5", "delta_compq_10"
)
invisible(lapply(columns_to_abs, function(col) {
BEA_ILPA_data[[paste0("abs_", col)]] <<- abs(BEA_ILPA_data[[col]])
}))
# Subset to only include when all delta_As aren't missing (so 2007 on)
BEA_ILPA_data$year <- as.character(BEA_ILPA_data$year)
regression_data <- resid_results_alt %>%
select(Code, year, delta_1, delta_1_resid, delta_logPratio_1_II)
# generate absolute values
regression_data$abs_delta_1 <- abs(regression_data$delta_1)
regression_data$abs_delta_1_resid <- abs(regression_data$delta_1_resid)
regression_data$abs_delta_logPratio_1 <- abs(regression_data$delta_logPratio_1)
# recover maximum by Code-year for abs_delta_1, abs_delta_1_resid, etc...
regression_data_sum <- regression_data %>%
group_by(Code, year) %>%
summarise(
sum_delta_1 = sum(abs_delta_1, na.rm = TRUE),
sum_delta_1_resid = sum(abs_delta_1_resid, na.rm = TRUE)
)
regression_data_sum <- merge(regression_data_sum, BEA_ILPA_data, by = c("Code", "year"))
# Define formulas for regression
formulas <- list(
sum_delta_1 ~ abs_delta_software_1,
sum_delta_1_resid ~ abs_delta_software_1,
sum_delta_1 ~ abs_delta_it_1,
sum_delta_1_resid ~ abs_delta_it_1,
sum_delta_1 ~ abs_delta_compq_1,
sum_delta_1_resid ~ abs_delta_compq_1
)
formula_names <- c(
"sum_1_software_abs",
"sum_resid_1_software_abs",
"sum_1_it_abs",
"sum_resid_1_it_abs",
"sum_1_compq_abs",
"sum_resid_1_compq_abs"
)
results <- lapply(formulas, reg_wrapper, data = regression_data_sum)
names(results) <- formula_names
#######################
# Slides regression
#######################
coef_map <- list(
"abs_delta_software_1" = "Correlation",
"abs_delta_it_1" = "Correlation",
"abs_delta_compq_1" = "Correlation",
"abs_delta_software_5" = "Correlation",
"abs_delta_it_5" = "Correlation",
"abs_delta_compq_5" = "Correlation",
"abs_delta_software_10" = "Correlation",
"abs_delta_it_10" = "Correlation",
"abs_delta_compq_10" = "Correlation")
#######################
# OG regressions comparison
#######################
texreg(list(results[['sum_resid_1_software_abs']][[1]], results[['sum_resid_1_compq_abs']][[1]], results[['sum_resid_1_it_abs']][[1]]), override.se = list(results[['sum_resid_1_software_abs']][[2]], results[['sum_resid_1_compq_abs']][[2]], results[['sum_resid_1_it_abs']][[2]]), override.pvalues = list(results[['sum_resid_1_software_abs']][[3]], results[['sum_resid_1_compq_abs']][[3]], results[['sum_resid_1_it_abs']][[3]]), custom.coef.map = coef_map, custom.model.names = c("Software", "Computer", "IT"), include.rsquared = FALSE, include.adjrs = FALSE, stars = c(.1, .05, .01), table = FALSE, file = "../tables/og_resid_Int_mainresults_1yr_altResid.tex")
patents_lp_omega
patents_lp_omega_alt
patents_lp_omega
library(lpirfs)
library(plm)
library(dplyr)
library(ggplot2)
source("helper_fncts.R")
# load residuals data
load("../data/cleaned/resid_results_1997_2022.RData")
# load BEA + Patents data
load("../data/cleaned/BEA_ILPA_data.RData")
load("../data/cleaned/patent_data_agg.RData")
load("../data/cleaned/summary_naics_crosswalk.RData")
# we have to use Code_patent, to account for multiple Codes mapping to some NAICS 3-digit
temp <- resid_results[, c("Code", "year", "delta_1", "delta_1_resid")]
temp <- merge(temp, summary_naics_crosswalk, by = "Code")
panel_data <- temp %>%
group_by(Code_patent, year) %>%
summarise(
sum_delta_1 = sum(abs(delta_1), na.rm = TRUE),
sum_delta_1_resid = sum(abs(delta_1_resid), na.rm = TRUE)
)
panel_data <- merge(panel_data, patent_data_agg, by = c("Code_patent", "year"), all.x = TRUE, all.y = FALSE)
panel_data <- panel_data[, c("Code_patent", "year", "sum_delta_1", "sum_delta_1_resid", "patents_xi_real", "patents_num", "patents_cites")]
# local projections
patents_lp_og <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1", shock = "patents_xi_real", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_resid <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_xi_real", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_og_alt <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1", shock = "patents_cites", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_resid_alt <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_cites", confint = 1.65, hor = 15, cumul_mult = FALSE)
# plot and save
patents_lp_both <- graph_lp_both(patents_lp_og, patents_lp_resid)
patents_lp_both_alt <- graph_lp_both(patents_lp_og_alt, patents_lp_resid_alt)
patents_lp <- graph_lp_one(patents_lp_resid, "resid")
patents_lp_alt <- graph_lp_one(patents_lp_resid_alt, "resid")
ggsave("../figures/local_projections/patents_lp_Int_both.pdf", patents_lp_both, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int_both_alt.pdf", patents_lp_both_alt, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int_alt.pdf", patents_lp_alt, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int.pdf", patents_lp, width = 9, height = 9)
View(panel_data)
source("~/Library/CloudStorage/GoogleDrive-jacob.gosselin@u.northwestern.edu/My Drive/research_ideas/changing_network/code/clean_patents.R")
View(patent_data_agg)
library(lpirfs)
library(plm)
library(dplyr)
library(ggplot2)
source("helper_fncts.R")
# load residuals data
load("../data/cleaned/resid_results_1997_2022.RData")
# load BEA + Patents data
load("../data/cleaned/BEA_ILPA_data.RData")
load("../data/cleaned/patent_data_agg.RData")
load("../data/cleaned/summary_naics_crosswalk.RData")
# we have to use Code_patent, to account for multiple Codes mapping to some NAICS 3-digit
temp <- resid_results[, c("Code", "year", "delta_1", "delta_1_resid")]
temp <- merge(temp, summary_naics_crosswalk, by = "Code")
panel_data <- temp %>%
group_by(Code_patent, year) %>%
summarise(
sum_delta_1 = sum(abs(delta_1), na.rm = TRUE),
sum_delta_1_resid = sum(abs(delta_1_resid), na.rm = TRUE)
)
panel_data <- merge(panel_data, patent_data_agg, by = c("Code_patent", "year"), all.x = TRUE, all.y = FALSE)
panel_data <- panel_data[, c("Code_patent", "year", "sum_delta_1", "sum_delta_1_resid", "patents_xi_real", "patents_num", "patents_cites")]
# local projections
patents_lp_og <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1", shock = "patents_xi_real", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_resid <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_xi_real", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_og_alt <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1", shock = "patents_cites", confint = 1.65, hor = 15, cumul_mult = FALSE)
patents_lp_resid_alt <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_cluster = "group", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_cites", confint = 1.65, hor = 15, cumul_mult = FALSE)
# plot and save
patents_lp_both <- graph_lp_both(patents_lp_og, patents_lp_resid)
patents_lp_both_alt <- graph_lp_both(patents_lp_og_alt, patents_lp_resid_alt)
patents_lp <- graph_lp_one(patents_lp_resid, "resid")
patents_lp_alt <- graph_lp_one(patents_lp_resid_alt, "resid")
ggsave("../figures/local_projections/patents_lp_Int_both.pdf", patents_lp_both, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int_both_alt.pdf", patents_lp_both_alt, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int_alt.pdf", patents_lp_alt, width = 16, height = 9)
ggsave("../figures/local_projections/patents_lp_Int.pdf", patents_lp, width = 9, height = 9)
patents_lp
patents_lp_alt
patents_lp
source("~/Documents(local)/GitHub/HeterogeousSectoralProduction/code/master_run_1947-1996.R")
# load libraries
library(dplyr)
library(tidyr)
library(readxl)
library(fixest)
source("../code/helper_fncts.R")
# load data
load("../data/cleaned/resid_data_1998_2023.RData") # load api data
# remove NaNs
resid_data_clean <- resid_data_1998_2023 %>%
filter(!is.na(delta_1) & !is.infinite(delta_1))
# generate industry_year factor
resid_data_clean$industry_year <- factor(paste(resid_data_clean$Code, resid_data_clean$year, sep = "-"))
resid_data_clean$input_year <- factor(paste(resid_data_clean$j, resid_data_clean$year, sep = "-"))
library(fixest)
# load data
load("../data/cleaned/resid_data_1998_2023.RData") # load non-api data
# remove NaNs (log changes involving 0 spending)
resid_data_clean <- resid_data_1998_2023 %>%
filter(!is.na(delta_1) & !is.infinite(delta_1))
# generate industry_year factor
resid_data_clean$industry_year <- factor(paste(resid_data_clean$Code, resid_data_clean$year, sep = "-"))
resid_data_clean$input_year <- factor(paste(resid_data_clean$j, resid_data_clean$year, sep = "-"))
# run residualizing regression
mod_main <- feols(delta_1 ~ delta_logPj_1:Code | industry_year, data = resid_data_clean)
mod_main_sum <- summary(mod_main, vcov_cluster("industry_year"))
# store residuals
resid_results <- resid_data_clean
resid_results$resid <- mod_main$residuals
# save estimates
save(mod_main, mod_main_sum, resid_results, file = "../data/cleaned/main_results.RData")
load("../data/cleaned/main_results.RData")
library(ggplot2)
library(dplyr)
library(tidyr)
coef_names <- names(coef(mod_main_sum))
theta_i <- as.data.frame(mod_main_sum$coefficients[grep("delta_logPj_1:", coef_names, value = TRUE)])
colnames(theta_i) <- "beta"
theta_i$coef <- rownames(theta_i)
theta_i <- separate(theta_i, coef, into = c("term", "Code"), sep = ":")
theta_i$theta <- 1 - theta_i$beta
theta_i$se <- mod_main_sum$se[grep("delta_logPj_1:", coef_names, value = TRUE)]
theta_i$Code <- gsub("Code", "", theta_i$Code)
# generate counter for Code
theta_i$Code_lab <- as.numeric(factor(theta_i$Code, levels = unique(theta_i$Code)))
# plot theta_i +/- 1 SE for each Code
theta_i_plot <- ggplot(theta_i, aes(x = Code_lab, y = theta)) +
geom_point() +
geom_errorbar(aes(ymin = theta - 1.65*se, ymax = theta + 1.65*se), width = 0.2) +
theme_minimal() +
labs(title = "", x = "", y = expression(~theta[i])) + # suppress xlabel
theme(text = element_text(family = "serif", size = 24)) +
geom_hline(yintercept = 0, linetype = "dashed") +
geom_hline(yintercept = 1, linetype = "dashed") +
# count every 10
scale_x_continuous(breaks = seq(0, max(theta_i$Code_lab), by = 10), labels = seq(0, max(theta_i$Code_lab), by = 10))
ggsave("../figures/elasticity_est/elasticities_main.pdf", theta_i_plot, width = 16, height = 9)
# save theta_i table
load("../data/cleaned/code_desc_crosswalk.RData")
theta_i_tab <- merge(theta_i, code_desc_crosswalk, by = "Code")
theta_i_tab <- theta_i_tab %>%
rename("Industry" = "Industry Description") %>%
mutate(Elasticity = round(theta, 3),
SE = round(se, 3),
Industry = ifelse(nchar(Industry) > 50, paste(substr(Industry, 1, 50), "...", sep=""), Industry),
Code = Code_lab) %>%
select(Code, Industry, Elasticity, SE)
# write as long table to latex
write.table(theta_i_tab, file = "../tables/elasticities_main.tex", sep = " & ", row.names = FALSE, col.names = FALSE, quote = FALSE, eol = " \\\\\n")
load("../data/cleaned/main_results.RData")
library(ggplot2)
library(dplyr)
library(tidyr)
coef_names <- names(coef(mod_main_sum))
theta_i <- as.data.frame(mod_main_sum$coefficients[grep("delta_logPj_1:", coef_names, value = TRUE)])
colnames(theta_i) <- "beta"
theta_i$coef <- rownames(theta_i)
theta_i <- separate(theta_i, coef, into = c("term", "Code"), sep = ":")
theta_i$theta <- 1 - theta_i$beta
theta_i$se <- mod_main_sum$se[grep("delta_logPj_1:", coef_names, value = TRUE)]
theta_i$Code <- gsub("Code", "", theta_i$Code)
# generate counter for Code
theta_i$Code_lab <- as.numeric(factor(theta_i$Code, levels = unique(theta_i$Code)))
# plot theta_i +/- 1 SE for each Code
theta_i_plot <- ggplot(theta_i, aes(x = Code_lab, y = theta)) +
geom_point() +
geom_errorbar(aes(ymin = theta - 1.65*se, ymax = theta + 1.65*se), width = 0.2) +
theme_minimal() +
labs(title = "", x = "", y = expression(~theta[i])) + # suppress xlabel
theme(text = element_text(family = "serif", size = 24)) +
geom_hline(yintercept = 0, linetype = "dashed") +
geom_hline(yintercept = 1, linetype = "dashed") +
# count every 10
scale_x_continuous(breaks = seq(0, max(theta_i$Code_lab), by = 10), labels = seq(0, max(theta_i$Code_lab), by = 10))
ggsave("../figures/elasticity_est/elasticities_main.pdf", theta_i_plot, width = 16, height = 9)
# save theta_i table
load("../data/cleaned/code_desc_crosswalk.RData")
theta_i_tab <- merge(theta_i, code_desc_crosswalk, by = "Code")
theta_i_tab <- theta_i_tab %>%
rename("Industry" = "Industry Description") %>%
mutate(Elasticity = round(theta, 3),
SE = round(se, 3),
Industry = ifelse(nchar(Industry) > 50, paste(substr(Industry, 1, 50), "...", sep=""), Industry),
Code = Code_lab) %>%
select(Code, Industry, Elasticity, SE)
# write as long table to latex
write.table(theta_i_tab, file = "../tables/elasticities_main.tex", sep = " & ", row.names = FALSE, col.names = FALSE, quote = FALSE, eol = " \\\\\n")
library(lpirfs)
library(dplyr)
library(ggplot2)
# load BEA + Patents data
load("../data/cleaned/patent_data_agg.RData")
# we have to use Code_patent, to account for multiple Codes mapping to some NAICS 3-digit
resid_results$delta_1_resid <- resid_results$resid
temp <- resid_results[, c("Code", "year", "delta_1", "delta_1_resid")]
panel_data <- temp %>%
group_by(Code, year) %>%
summarise(
sum_delta_1 = sum(abs(delta_1), na.rm = TRUE),
sum_delta_1_resid = sum(abs(delta_1_resid), na.rm = TRUE)
)
panel_data <- merge(panel_data, patent_data_agg, by = c("Code", "year"), all.x = TRUE, all.y = TRUE)
panel_data <- panel_data[, c("Code", "year", "sum_delta_1", "sum_delta_1_resid", "patents_xi_real", "patents_num", "patents_cites")]
# local projections
patents_value_lp_og <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_method = "white1", diff_shock = FALSE, endog_data = "sum_delta_1", shock = "patents_xi_real", confint = 1, hor = 15, cumul_mult = FALSE)
patents_value_lp_resid <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_method = "white1", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_xi_real", confint = 1, hor = 15, cumul_mult = FALSE)
patents_citations_lp_og <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_method = "white1", diff_shock = FALSE, endog_data = "sum_delta_1", shock = "patents_cites", confint = 1, hor = 15, cumul_mult = FALSE)
patents_citations_lp_resid <- lp_lin_panel(panel_data, panel_model = "within", panel_effect = "twoways", robust_cov = "vcovHC", robust_method = "white1", diff_shock = FALSE, endog_data = "sum_delta_1_resid", shock = "patents_cites", confint = 1, hor = 15, cumul_mult = FALSE)
# plot and save
patents_value_lp_both <- graph_lp_both(patents_value_lp_og, patents_value_lp_resid)
patents_citations_lp_both <- graph_lp_both(patents_citations_lp_og, patents_citations_lp_resid)
patents_value_lp <- graph_lp_one(patents_value_lp_resid, "resid")
patents_citations_lp <- graph_lp_one(patents_citations_lp_resid, "resid")
ggsave("../figures/local_projections/patents_value_resid.pdf", patents_value_lp, width = 9, height = 9)
ggsave("../figures/local_projections/patents_citations_resid.pdf", patents_citations_lp, width = 16, height = 9)
library(texreg)
library(tidyr)
library(dplyr)
# load Atalay data
load("../data/cleaned/atalay_instruments.RData")
# merge
atalay_comparison <- merge(resid_data_clean, atalay_instruments, by = c("Code", "year", "j"))
top_10_subset <- resid_data_clean %>%
group_by(Code, year) %>%
top_n(10, val) %>%
filter(year < 2014)
atalay_comparison_subset <- merge(top_10_subset, atalay_instruments, by = c("Code", "year", "j"))
# run IV regression
atalay_IV <- feols(delta_1 ~ 1 | Code + year | delta_logPratio_1_II ~ military_shock_i + military_shock_j + military_shock_suppliers, data = atalay_comparison)
atalay_comp <- feols(delta_1 ~ delta_logPj_1 | industry_year, data = atalay_comparison)
atalay_IV_subset <- feols(delta_1_Out ~ 1 | Code + year | delta_logPratio_1_II + delta_logPratio_1_IIOut ~ military_shock_i +  military_shock_j + military_shock_suppliers, data = atalay_comparison_subset)
atalay_comp_subset <- feols(delta_1 ~ delta_logPj_1 | industry_year, data = atalay_comparison_subset)
# texreg output
# use cluster robust SEs
atalay_IV_sum_robust <- summary(atalay_IV, vcov = "hetero")
atalay_comp_sum_robust <- summary(atalay_comp, vcov = "hetero")
atalay_IV_sum_cluster <- summary(atalay_IV, vcov_cluster("industry_year"))
atalay_comp_sum_cluster <- summary(atalay_comp, vcov_cluster("industry_year"))
atalay_IV_sum_subset_robust <- summary(atalay_IV_subset, vcov = "hetero")
atalay_comp_sum_subset_robust <- summary(atalay_comp_subset, vcov = "hetero")
atalay_IV_sum_subset_cluster <- summary(atalay_IV_subset, vcov_cluster("industry_year"))
atalay_comp_sum_subset_cluster <- summary(atalay_comp_subset, vcov_cluster("industry_year"))
# texreg results
# override coef, use 1-coefficient
coef_map <- list(
"delta_logPj_1" = "Elasticity",
"fit_delta_logPratio_1_II" = "Elasticity"
)
texreg(list(atalay_comp_sum_robust, atalay_IV_sum_robust, atalay_comp_sum_cluster, atalay_IV_sum_cluster), custom.coef.map = coef_map, custom.model.names = c("Uniform", "Atalay IV", "Uniform", "Atalay IV"), custom.header = list("Robust SE" = 1:2, "Clustered SE" = 3:4), include.rsquared = FALSE, include.adjrs = FALSE, table = FALSE, file = "../tables/atalay_comparison.tex", override.coef = list(1 - atalay_comp_sum_robust$coefficients, 1 - atalay_IV_sum_robust$coefficients, 1 - atalay_comp_sum_cluster$coefficients, 1 - atalay_IV_sum_cluster$coefficients), include.nobs=FALSE, include.groups=FALSE, stars = numeric(0))
coef_map <- list(
"delta_logPj_1" = "Elasticity (inner-nest)",
"fit_delta_logPratio_1_II" = "Elasticity (inner-nest)",
"fit_delta_logPratio_1_IIOut" = "Elasticity (outer-nest)"
)
# texreg(list(atalay_comp_sum_subset_robust, atalay_IV_sum_subset_robust, atalay_comp_sum_subset_cluster,  atalay_IV_sum_subset_cluster), custom.coef.map = coef_map, custom.model.names = c("Uniform", "Atalay IV", "Uniform", "Atalay IV"), custom.header = list("Robust SE" = 1:2, "Clustered SE" = 3:4), include.rsquared = FALSE, include.adjrs = FALSE, table = FALSE, file = "../tables/atalay_comparison_subset.tex", override.coef = list(1 - atalay_comp_sum_subset_robust$coefficients, 1 - atalay_IV_sum_subset_robust$coefficients,1 - atalay_comp_sum_subset_cluster$coefficients, 1 - atalay_IV_sum_subset_cluster$coefficients), include.nobs=FALSE, include.groups=FALSE, stars = numeric(0))
